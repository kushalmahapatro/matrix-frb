// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_timeline_sdk_by_room_id`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `RoomView`, `TimelineKind`, `Timeline`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `clone`, `get_message_from_timeline_item`, `new`

Future<List<Message>> getTimelineItemsByRoomId({required String roomId}) =>
    RustLib.instance.api.crateMatrixTimelinesGetTimelineItemsByRoomId(
      roomId: roomId,
    );

Stream<MessageUpdate> subscribeToTimelineUpdates({required String roomId}) =>
    RustLib.instance.api.crateMatrixTimelinesSubscribeToTimelineUpdates(
      roomId: roomId,
    );

class Message {
  final String eventId;
  final String sender;
  final String content;
  final BigInt timestamp;
  final MessageType messageType;

  const Message({
    required this.eventId,
    required this.sender,
    required this.content,
    required this.timestamp,
    required this.messageType,
  });

  @override
  int get hashCode =>
      eventId.hashCode ^
      sender.hashCode ^
      content.hashCode ^
      timestamp.hashCode ^
      messageType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Message &&
          runtimeType == other.runtimeType &&
          eventId == other.eventId &&
          sender == other.sender &&
          content == other.content &&
          timestamp == other.timestamp &&
          messageType == other.messageType;
}

enum MessageType { message, dateDivider, readMarker, timelineStart }

class MessageUpdate {
  final MessageUpdateType messageUpdateType;
  final List<Message>? messages;
  final BigInt? index;
  final BigInt? length;

  const MessageUpdate({
    required this.messageUpdateType,
    this.messages,
    this.index,
    this.length,
  });

  @override
  int get hashCode =>
      messageUpdateType.hashCode ^
      messages.hashCode ^
      index.hashCode ^
      length.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageUpdate &&
          runtimeType == other.runtimeType &&
          messageUpdateType == other.messageUpdateType &&
          messages == other.messages &&
          index == other.index &&
          length == other.length;
}

enum MessageUpdateType {
  reset,
  truncate,
  remove,
  set_,
  insert,
  popBack,
  popFront,
  pushBack,
  pushFront,
  clear,
  append,
}
