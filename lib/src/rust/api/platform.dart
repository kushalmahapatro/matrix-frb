// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'tracing.dart';
part 'platform.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `as_str`, `build_tracing_filter`, `build`, `format_timestamp`, `get_global_init_state`, `make_file_layer`, `new`, `set_global_init_state`, `setup_lightweight_tokio_runtime`, `setup_multithreaded_tokio_runtime`, `targets`, `text_layers`, `write_filename`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `EventFormatter`, `LogTarget`, `LoggingCtx`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `eq`, `format_event`, `format_fields`, `partial_cmp`

/// Sets up logs and the tokio runtime for the current application.
///
/// If `use_lightweight_tokio_runtime` is set to true, this will set up a
/// lightweight tokio runtime, for processes that have memory limitations (like
/// the NSE process on iOS). Otherwise, this can remain false, in which case a
/// multithreaded tokio runtime will be set up.
Future<void> initPlatform({
  required TracingConfiguration config,
  required bool useLightweightTokioRuntime,
}) => RustLib.instance.api.crateApiPlatformInitPlatform(
  config: config,
  useLightweightTokioRuntime: useLightweightTokioRuntime,
);

/// Updates the tracing subscriber with a new file writer based on the provided
/// configuration.
///
/// This method will throw if `init_platform` hasn't been called, or if it was
/// called with `write_to_files` set to `None`.
Future<void> reloadTracingFileWriter({
  required TracingFileConfiguration configuration,
}) => RustLib.instance.api.crateApiPlatformReloadTracingFileWriter(
  configuration: configuration,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FieldsFormatterForFiles>>
abstract class FieldsFormatterForFiles implements RustOpaqueInterface {
  static Future<FieldsFormatterForFiles> default_() =>
      RustLib.instance.api.crateApiPlatformFieldsFormatterForFilesDefault();
}

@freezed
sealed class ClientError with _$ClientError implements FrbException {
  const ClientError._();

  const factory ClientError.generic({required String msg, String? details}) =
      ClientError_Generic;
}

/// A log pack can be used to set the trace log level for a group of multiple
/// log targets at once, for debugging purposes.
enum TraceLogPacks {
  /// Enables all the logs relevant to the event cache.
  eventCache,

  /// Enables all the logs relevant to the send queue.
  sendQueue,

  /// Enables all the logs relevant to the timeline.
  timeline,

  /// Enables all the logs relevant to the notification client.
  notificationClient,
}

class TracingConfiguration {
  /// The desired log level.
  final LogLevel logLevel;

  /// All the log packs, that will be set to `TRACE` when they're enabled.
  final List<TraceLogPacks> traceLogPacks;

  /// Additional targets that the FFI client would like to use.
  ///
  /// This can include, for instance, the target names for created
  /// [`crate::tracing::Span`]. These targets will use the global log level by
  /// default.
  final List<String> extraTargets;

  /// Whether to log to stdout, or in the logcat on Android.
  final bool writeToStdoutOrSystem;

  /// If set, configures rotated log files where to write additional logs.
  final TracingFileConfiguration? writeToFiles;

  const TracingConfiguration({
    required this.logLevel,
    required this.traceLogPacks,
    required this.extraTargets,
    required this.writeToStdoutOrSystem,
    this.writeToFiles,
  });

  @override
  int get hashCode =>
      logLevel.hashCode ^
      traceLogPacks.hashCode ^
      extraTargets.hashCode ^
      writeToStdoutOrSystem.hashCode ^
      writeToFiles.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TracingConfiguration &&
          runtimeType == other.runtimeType &&
          logLevel == other.logLevel &&
          traceLogPacks == other.traceLogPacks &&
          extraTargets == other.extraTargets &&
          writeToStdoutOrSystem == other.writeToStdoutOrSystem &&
          writeToFiles == other.writeToFiles;
}

/// Configuration to save logs to (rotated) log-files.
class TracingFileConfiguration {
  /// Base location for all the log files.
  final String path;

  /// Prefix for the log files' names.
  final String filePrefix;

  /// Optional suffix for the log file's names.
  final String? fileSuffix;

  /// Maximum number of rotated files.
  ///
  /// If not set, there's no max limit, i.e. the number of log files is
  /// unlimited.
  final BigInt? maxFiles;

  const TracingFileConfiguration({
    required this.path,
    required this.filePrefix,
    this.fileSuffix,
    this.maxFiles,
  });

  @override
  int get hashCode =>
      path.hashCode ^
      filePrefix.hashCode ^
      fileSuffix.hashCode ^
      maxFiles.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TracingFileConfiguration &&
          runtimeType == other.runtimeType &&
          path == other.path &&
          filePrefix == other.filePrefix &&
          fileSuffix == other.fileSuffix &&
          maxFiles == other.maxFiles;
}
