// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_global_client`, `get_global_config`, `get_global_sync_status`, `init_globals`, `set_global_client`, `set_global_config`, `set_global_sync_status`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`

Future<bool> initClient({required MatrixClientConfig config}) =>
    RustLib.instance.api.crateApiMatrixClientInitClient(config: config);

Future<bool> login({required String username, required String password}) =>
    RustLib.instance.api.crateApiMatrixClientLogin(
      username: username,
      password: password,
    );

Future<bool> logout() => RustLib.instance.api.crateApiMatrixClientLogout();

Future<bool> performInitialSync() =>
    RustLib.instance.api.crateApiMatrixClientPerformInitialSync();

Future<List<MatrixRoomInfo>> getRooms() =>
    RustLib.instance.api.crateApiMatrixClientGetRooms();

Future<String> createRoom({required String name, String? topic}) => RustLib
    .instance
    .api
    .crateApiMatrixClientCreateRoom(name: name, topic: topic);

Future<bool> joinRoom({required String roomId}) =>
    RustLib.instance.api.crateApiMatrixClientJoinRoom(roomId: roomId);

Future<String> sendMessage({required String roomId, required String content}) =>
    RustLib.instance.api.crateApiMatrixClientSendMessage(
      roomId: roomId,
      content: content,
    );

Future<List<MatrixMessage>> getMessages({
  required String roomId,
  required int limit,
}) => RustLib.instance.api.crateApiMatrixClientGetMessages(
  roomId: roomId,
  limit: limit,
);

Future<SyncStatus> getSyncStatus() =>
    RustLib.instance.api.crateApiMatrixClientGetSyncStatus();

Future<bool> isLoggedIn() =>
    RustLib.instance.api.crateApiMatrixClientIsLoggedIn();

class MatrixClientConfig {
  final String homeserverUrl;
  final String storagePath;

  const MatrixClientConfig({
    required this.homeserverUrl,
    required this.storagePath,
  });

  @override
  int get hashCode => homeserverUrl.hashCode ^ storagePath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MatrixClientConfig &&
          runtimeType == other.runtimeType &&
          homeserverUrl == other.homeserverUrl &&
          storagePath == other.storagePath;
}

class MatrixMessage {
  final String eventId;
  final String sender;
  final String content;
  final BigInt timestamp;

  const MatrixMessage({
    required this.eventId,
    required this.sender,
    required this.content,
    required this.timestamp,
  });

  @override
  int get hashCode =>
      eventId.hashCode ^
      sender.hashCode ^
      content.hashCode ^
      timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MatrixMessage &&
          runtimeType == other.runtimeType &&
          eventId == other.eventId &&
          sender == other.sender &&
          content == other.content &&
          timestamp == other.timestamp;
}

class MatrixRoomInfo {
  final String roomId;
  final String? name;
  final String? topic;
  final BigInt memberCount;
  final bool isEncrypted;

  const MatrixRoomInfo({
    required this.roomId,
    this.name,
    this.topic,
    required this.memberCount,
    required this.isEncrypted,
  });

  @override
  int get hashCode =>
      roomId.hashCode ^
      name.hashCode ^
      topic.hashCode ^
      memberCount.hashCode ^
      isEncrypted.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MatrixRoomInfo &&
          runtimeType == other.runtimeType &&
          roomId == other.roomId &&
          name == other.name &&
          topic == other.topic &&
          memberCount == other.memberCount &&
          isEncrypted == other.isEncrypted;
}

class SyncStatus {
  final bool isSyncing;
  final BigInt roomsCount;
  final BigInt messagesCount;
  final BigInt? lastSyncTime;

  const SyncStatus({
    required this.isSyncing,
    required this.roomsCount,
    required this.messagesCount,
    this.lastSyncTime,
  });

  @override
  int get hashCode =>
      isSyncing.hashCode ^
      roomsCount.hashCode ^
      messagesCount.hashCode ^
      lastSyncTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SyncStatus &&
          runtimeType == other.runtimeType &&
          isSyncing == other.isSyncing &&
          roomsCount == other.roomsCount &&
          messagesCount == other.messagesCount &&
          lastSyncTime == other.lastSyncTime;
}
