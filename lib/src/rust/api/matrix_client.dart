// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `create_sync_stream`, `get_global_client`, `get_global_config`, `get_global_sync_status`, `init_globals`, `init_timeline_streams`, `set_global_client`, `set_global_config`, `set_global_sync_status`, `update_timeline`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Add or update a timeline stream for a room
Stream<RoomTimeline> setTimelineStream({required String roomId}) =>
    RustLib.instance.api.crateApiMatrixClientSetTimelineStream(roomId: roomId);

/// Send a timeline event to a room's stream
Future<void> sendToTimelineStream({
  required String roomId,
  required RoomTimeline timelineEvent,
}) => RustLib.instance.api.crateApiMatrixClientSendToTimelineStream(
  roomId: roomId,
  timelineEvent: timelineEvent,
);

/// Remove a timeline stream for a room
Future<void> removeTimelineStream({required String roomId}) => RustLib
    .instance
    .api
    .crateApiMatrixClientRemoveTimelineStream(roomId: roomId);

Stream<SyncEvent> initSyncStream() =>
    RustLib.instance.api.crateApiMatrixClientInitSyncStream();

Future<bool> initClient({required MatrixClientConfig config}) =>
    RustLib.instance.api.crateApiMatrixClientInitClient(config: config);

Future<bool> register({required String username, required String password}) =>
    RustLib.instance.api.crateApiMatrixClientRegister(
      username: username,
      password: password,
    );

Future<bool> login({required String username, required String password}) =>
    RustLib.instance.api.crateApiMatrixClientLogin(
      username: username,
      password: password,
    );

Future<bool> logout() => RustLib.instance.api.crateApiMatrixClientLogout();

Stream<MatrixRoomInfo> listenRoomUpdates() =>
    RustLib.instance.api.crateApiMatrixClientListenRoomUpdates();

Future<List<MatrixRoomInfo>> getRooms() =>
    RustLib.instance.api.crateApiMatrixClientGetRooms();

Stream<RoomTimeline> loadTimeline({required String roomId}) =>
    RustLib.instance.api.crateApiMatrixClientLoadTimeline(roomId: roomId);

Future<void> timelinePaginateForward({required String roomId}) => RustLib
    .instance
    .api
    .crateApiMatrixClientTimelinePaginateForward(roomId: roomId);

Future<void> timelinePaginateBackwards({required String roomId}) => RustLib
    .instance
    .api
    .crateApiMatrixClientTimelinePaginateBackwards(roomId: roomId);

Future<String> createRoom({required String name, String? topic}) => RustLib
    .instance
    .api
    .crateApiMatrixClientCreateRoom(name: name, topic: topic);

Future<bool> joinRoom({required String roomId}) =>
    RustLib.instance.api.crateApiMatrixClientJoinRoom(roomId: roomId);

Future<String> sendMessage({required String roomId, required String content}) =>
    RustLib.instance.api.crateApiMatrixClientSendMessage(
      roomId: roomId,
      content: content,
    );

Future<List<MatrixMessage>> getMessages({
  required String roomId,
  required int limit,
}) => RustLib.instance.api.crateApiMatrixClientGetMessages(
  roomId: roomId,
  limit: limit,
);

Future<SyncStatus> getSyncStatus() =>
    RustLib.instance.api.crateApiMatrixClientGetSyncStatus();

Future<bool> isLoggedIn() =>
    RustLib.instance.api.crateApiMatrixClientIsLoggedIn();

Future<void> syncOnce() => RustLib.instance.api.crateApiMatrixClientSyncOnce();

Future<void> startSlidingSync() =>
    RustLib.instance.api.crateApiMatrixClientStartSlidingSync();

Future<bool> isClientAuthenticated() =>
    RustLib.instance.api.crateApiMatrixClientIsClientAuthenticated();

class MatrixClientConfig {
  final String homeserverUrl;
  final String storagePath;

  const MatrixClientConfig({
    required this.homeserverUrl,
    required this.storagePath,
  });

  @override
  int get hashCode => homeserverUrl.hashCode ^ storagePath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MatrixClientConfig &&
          runtimeType == other.runtimeType &&
          homeserverUrl == other.homeserverUrl &&
          storagePath == other.storagePath;
}

class MatrixMessage {
  final String eventId;
  final String sender;
  final String content;
  final BigInt timestamp;

  const MatrixMessage({
    required this.eventId,
    required this.sender,
    required this.content,
    required this.timestamp,
  });

  @override
  int get hashCode =>
      eventId.hashCode ^
      sender.hashCode ^
      content.hashCode ^
      timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MatrixMessage &&
          runtimeType == other.runtimeType &&
          eventId == other.eventId &&
          sender == other.sender &&
          content == other.content &&
          timestamp == other.timestamp;
}

class MatrixRoomInfo {
  final String roomId;
  final String? name;
  final String? topic;
  final BigInt memberCount;
  final MatrixMessage? latestEvent;
  final BigInt? latestEventTimestamp;

  const MatrixRoomInfo({
    required this.roomId,
    this.name,
    this.topic,
    required this.memberCount,
    this.latestEvent,
    this.latestEventTimestamp,
  });

  @override
  int get hashCode =>
      roomId.hashCode ^
      name.hashCode ^
      topic.hashCode ^
      memberCount.hashCode ^
      latestEvent.hashCode ^
      latestEventTimestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MatrixRoomInfo &&
          runtimeType == other.runtimeType &&
          roomId == other.roomId &&
          name == other.name &&
          topic == other.topic &&
          memberCount == other.memberCount &&
          latestEvent == other.latestEvent &&
          latestEventTimestamp == other.latestEventTimestamp;
}

class RoomTimeline {
  final String eventId;
  final String sender;
  final String content;
  final BigInt timestamp;

  const RoomTimeline({
    required this.eventId,
    required this.sender,
    required this.content,
    required this.timestamp,
  });

  @override
  int get hashCode =>
      eventId.hashCode ^
      sender.hashCode ^
      content.hashCode ^
      timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RoomTimeline &&
          runtimeType == other.runtimeType &&
          eventId == other.eventId &&
          sender == other.sender &&
          content == other.content &&
          timestamp == other.timestamp;
}

class SyncEvent {
  final String eventType;
  final String? roomId;
  final String? eventId;
  final String? sender;
  final String? content;
  final BigInt? timestamp;
  final BigInt syncTime;

  const SyncEvent({
    required this.eventType,
    this.roomId,
    this.eventId,
    this.sender,
    this.content,
    this.timestamp,
    required this.syncTime,
  });

  @override
  int get hashCode =>
      eventType.hashCode ^
      roomId.hashCode ^
      eventId.hashCode ^
      sender.hashCode ^
      content.hashCode ^
      timestamp.hashCode ^
      syncTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SyncEvent &&
          runtimeType == other.runtimeType &&
          eventType == other.eventType &&
          roomId == other.roomId &&
          eventId == other.eventId &&
          sender == other.sender &&
          content == other.content &&
          timestamp == other.timestamp &&
          syncTime == other.syncTime;
}

class SyncStatus {
  final bool isSyncing;
  final BigInt roomsCount;
  final BigInt messagesCount;
  final BigInt? lastSyncTime;

  const SyncStatus({
    required this.isSyncing,
    required this.roomsCount,
    required this.messagesCount,
    this.lastSyncTime,
  });

  @override
  int get hashCode =>
      isSyncing.hashCode ^
      roomsCount.hashCode ^
      messagesCount.hashCode ^
      lastSyncTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SyncStatus &&
          runtimeType == other.runtimeType &&
          isSyncing == other.isSyncing &&
          roomsCount == other.roomsCount &&
          messagesCount == other.messagesCount &&
          lastSyncTime == other.lastSyncTime;
}
